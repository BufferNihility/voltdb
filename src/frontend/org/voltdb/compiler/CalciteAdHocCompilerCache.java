/* This file is part of VoltDB.
 * Copyright (C) 2008-2019 VoltDB Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.voltdb.compiler;

import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import org.voltdb.planner.CorePlan;
import org.voltdb.utils.Encoder;

import com.google.common.base.Preconditions;
import com.google_voltpatches.common.cache.Cache;
import com.google_voltpatches.common.cache.CacheBuilder;

/**
 * Keep a two level cache of plans generated by the Ad Hoc
 * planner.
 *
 * First, store literals mapping to full plans that are
 * ready to execute.
 *
 * Second, store a string representation of a parameterized parsed
 * statement mapped to core parameterized plans. These parameterized
 * plans need parameter values and sql literals in order to be
 * actually used.
 */
public class CalciteAdHocCompilerCache implements Serializable {
    private static final long serialVersionUID = 1L;

    //////////////////////////////////////////////////////////////////////////
    // STATIC CODE TO MANAGE CACHE LIFETIMES / GLOBALNESS
    //////////////////////////////////////////////////////////////////////////

    // weak values should remove the object when the catalog hash is no longer needed
    private static Cache<String, CalciteAdHocCompilerCache> m_catalogHashMatch =
            CacheBuilder.newBuilder().weakValues().build();

    public static void clearHashCache() {
        m_catalogHashMatch.invalidateAll();
    }

    /**
     * Get the global cache for a given hash of the catalog. If not found, create a new one.
     * Note that there can be only one cache per catalogHash at a time.
     */
    public synchronized static CalciteAdHocCompilerCache getCacheForCatalogHash(byte[] catalogHash) {
        String hashString = Encoder.hexEncode(catalogHash);
        CalciteAdHocCompilerCache cache = m_catalogHashMatch.getIfPresent(hashString);
        if (cache == null) {
            cache = new CalciteAdHocCompilerCache();
            m_catalogHashMatch.put(hashString, cache);
        }
        return cache;
    }

    //////////////////////////////////////////////////////////////////////////
    // PER-INSTANCE AWESOMEC CACHING CODE
    //////////////////////////////////////////////////////////////////////////

    // max memory space for parameterized plans
    final long MAX_LITERAL_MEM  = Long.getLong("ADHOC_COMPILER_CACHE_MAX_LITERAL_MEM_BYTES", 32*1024*1024);

    /** cache of literals to full plans */
    final Map<String, AdHocPlannedStatement> m_literalCache;
    /** cache of parameterized plan */
    final Map<String, CorePlan> m_coreCache;

    // placeholder stats used during development that may/may not survive
    long m_literalHits = 0;
    long m_literalQueries = 0;
    long m_literalInsertions = 0;
    long m_literalEvictions = 0;
    long m_planHits = 0;
    long m_planQueries = 0;
    long m_planInsertions = 0;
    long m_planEvictions = 0;
    /** {@see this#startPeriodicStatsPrinting() } */
    Timer m_statsTimer = null;

    /**
     * Constructor with default cache sizes.
     */
    private CalciteAdHocCompilerCache() {
        this(1000, 1000);
    }

    /**
     * Constructor with specific cache sizes is only called directly for testing.
     *
     * @param maxLiteralEntries cache size for literals
     * @param maxLiteralMem cache memory for literals
     */
    CalciteAdHocCompilerCache(int maxLiteralEntries, int maxCoreEntries) {

        // an LRU cache map
        m_literalCache = new AdHocStatementCache(maxLiteralEntries, MAX_LITERAL_MEM) {
            private static final long serialVersionUID = 1L;

            // This method is called just after a new entry has been added
            @Override
            public boolean removeEldestEntry(final Map.Entry<String, AdHocPlannedStatement> eldest) {
                if ((size() > maxEntries) || (this.currentMemory > this.maxMemory))  {
                    ++m_literalEvictions;
                    this.currentMemory -= eldest.getValue().getSerializedSize();
                    return true;
                }
                return false;
            }
        };

        // an LRU cache map
        m_coreCache = new LinkedHashMap<String, CorePlan>(maxCoreEntries, .75f, true) {
            private static final long serialVersionUID = 1L;

            // This method is called just after a new entry has been added
            @Override
            public boolean removeEldestEntry(Map.Entry<String, CorePlan> eldest) {
                if (size() > maxCoreEntries) {
                    ++m_planEvictions;
                    return true;
                }
                return false;
            }
        };
    }

    /**
     * Stats printing method used during development.
     * Probably shouldn't live past real stats integration.
     */
    synchronized void printStats() {
        String line1 = String.format("CACHE STATS - Literals: Hits %d/%d (%.1f%%), Inserts %d Evictions %d\n",
                m_literalHits, m_literalQueries, (m_literalHits * 100.0) / m_literalQueries,
                m_literalInsertions, m_literalEvictions);
        String line2 = String.format("CACHE STATS - Plans:    Hits %d/%d (%.1f%%), Inserts %d Evictions %d\n",
                m_planHits, m_planQueries, (m_planHits * 100.0) /m_planQueries,
                m_planInsertions, m_planEvictions);

        System.out.print(line1 + line2);
        System.out.flush();

        // reset these
        m_literalHits = 0;
        m_literalQueries = 0;
        m_literalInsertions = 0;
        m_literalEvictions = 0;
        m_planHits = 0;
        m_planQueries = 0;
        m_planInsertions = 0;
        m_planEvictions = 0;
    }

    /**
     * @param sql SQL literal
     * @return full, ready-to-go plan
     */
    public synchronized AdHocPlannedStatement getWithSQL(String sql) {
        ++m_literalQueries;
        AdHocPlannedStatement retval = m_literalCache.get(sql);
        if (retval != null) {
            ++m_literalHits;
        }
        return retval;
    }

    /**
     * @param parsedQuery String representing a parameterized and parsed
     * SQL statement
     * @return A list of CorePlan that needs parameter values to run.
     */
    public synchronized CorePlan getWithParsedQuery(String parsedQuery) {
        ++m_planQueries;
        CorePlan retval = m_coreCache.get(parsedQuery);
        if (retval != null) {
            ++m_planHits;
        }
        return retval;
    }

    /**
     * Called from the PlannerTool directly when it finishes planning.
     * This is the only way to populate the cache.
     *
     * Note that one goal here is to reduce the number of times two
     * separate plan instances with the same value are input for the
     * same SQL literal.
     *
     * L1 cache (literal cache) cache SQL queries without user provided parameters.
     * L2 cache (core cache) cache parameterized queries: including user parameters and auto extracted parameters.
     *
     * @param originalQuery               original query text
     * @param parameterizedQuery          parameterized query with literals take out
     * @param planIn
     * @param extractedLiterals           the basis values for any "bound parameter" restrictions to plan re-use
     * @param hasUserQuestionMarkParameters is user provided parameterized query
     * @param hasAutoParameterizedException is the auto parameterized query has parameter exception
     */
    public synchronized void put(String originalQuery,
                                 String parameterizedQuery,
                                 AdHocPlannedStatement planIn,
                                 String[] extractedLiterals,
                                 boolean hasUserQuestionMarkParameters,
                                 boolean hasAutoParameterizedException)
    {
        Preconditions.checkNotNull(originalQuery);
        Preconditions.checkNotNull(parameterizedQuery);
        Preconditions.checkNotNull(planIn);

        // hasUserQuestionMarkParameters and hasAutoParameterizedException can not be true at the same time
        // it means that a query can not be both user parameterized query and auto parameterized query.
        // refer https://github.com/VoltDB/voltdb/pull/2313#discussion_r30084169
        assert(!hasUserQuestionMarkParameters || !hasAutoParameterizedException);

        // deal with L2 cache
        if (! hasAutoParameterizedException) {
            // deal with the parameterized plan cache first
            CorePlan corePlan = m_coreCache.get(parameterizedQuery);

            if (corePlan == null) {
                corePlan = planIn.core;
                m_coreCache.put(parameterizedQuery, corePlan);
                ++m_planInsertions;
            } else {
                assert(corePlan.equals(planIn.core));
            }
        }

        // then deal with the L1 cache
        if (! hasUserQuestionMarkParameters) {
            AdHocPlannedStatement cachedPlan = m_literalCache.get(originalQuery);
            if (cachedPlan == null) {
                //* enable to debug */ System.out.println("DEBUG: Caching literal '" + sql + "'");
                m_literalCache.put(originalQuery, planIn);
                ++m_literalInsertions;
            } else {
                assert(cachedPlan.equals(planIn));
            }
        }
    }

    /**
     * Start a timer that prints cache stats to the console every 5s.
     * Used for development until we get better stats integration.
     */
    public void startPeriodicStatsPrinting() {
        if (m_statsTimer == null) {
            m_statsTimer = new Timer();
            m_statsTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    printStats();
                }
            }, 5000, 5000);
        }
    }

    /**
     * Return the number of items in the literal cache.
     * @return  literal cache size as a count
     */
    public int getLiteralCacheSize() {
        return m_literalCache.size();
    }

    /**
     * Return the number of items in the core (parameterized) cache.
     * @return  core cache size as a count
     */
    public int getCoreCacheSize() {
        return m_coreCache.size();
    }
}
